# Code Coverage Improvement Plan

**Date:** 2025-12-20
**Project:** mddedupe v1.1.0
**Starting Coverage:** 85.93% (llvm-cov)
**Final Coverage:** 97.40% (2589/2658 lines)
**Target Coverage:** 98%
**Status:** COMPLETED (within 0.6% of target)

---

## Overview

This plan outlined a multi-stage approach to improve code coverage from 85.93% to 98%. The final coverage of 97.40% represents the practical ceiling for Windows-based testing, with remaining gaps being platform-specific Unix code and `main()` function code that uses `process::exit()`.

---

## Stage 1: Quick Wins (Est. +30 lines, Target: ~82%)

### 1.1 Remove Dead Code
**Target:** `ansi_rgb()` function (lines 118-120)

This function is defined but never called anywhere in the codebase. Options:
- **Option A (Recommended):** Remove the function entirely
- **Option B:** Add a test if it's intended for future use

**Action:** Remove the unused function.

### 1.2 Test Utility Functions Directly

#### 1.2.1 `is_cross_device_error()` (lines 530-536)
Add unit tests with synthetic `io::Error` objects:
```rust
#[test]
fn test_is_cross_device_error_posix() {
    let err = io::Error::from_raw_os_error(18);
    assert!(is_cross_device_error(&err));
}

#[test]
fn test_is_cross_device_error_windows() {
    let err = io::Error::from_raw_os_error(17);
    assert!(is_cross_device_error(&err));
}

#[test]
fn test_is_cross_device_error_other() {
    let err = io::Error::new(io::ErrorKind::Other, "test");
    assert!(!is_cross_device_error(&err));
}
```

#### 1.2.2 `is_broken_pipe()` Raw OS Error Paths (lines 538-543)
```rust
#[test]
fn test_is_broken_pipe_os_error_32() {
    let err = io::Error::from_raw_os_error(32);
    assert!(is_broken_pipe(&err));
}

#[test]
fn test_is_broken_pipe_os_error_109() {
    let err = io::Error::from_raw_os_error(109);
    assert!(is_broken_pipe(&err));
}
```

#### 1.2.3 `write_summary_to_path()` (lines 570-581)
```rust
#[test]
fn test_write_summary_to_path_creates_parent_dirs() {
    let temp = TempDir::new().unwrap();
    let nested = temp.path().join("a/b/c/summary.txt");
    write_summary_to_path(&nested, "test content").unwrap();
    assert!(nested.exists());
}

#[test]
fn test_write_summary_to_path_adds_newline() {
    let temp = TempDir::new().unwrap();
    let path = temp.path().join("summary.txt");
    write_summary_to_path(&path, "no newline").unwrap();
    let content = fs::read_to_string(&path).unwrap();
    assert!(content.ends_with('\n'));
}

#[test]
fn test_write_summary_to_path_preserves_existing_newline() {
    let temp = TempDir::new().unwrap();
    let path = temp.path().join("summary.txt");
    write_summary_to_path(&path, "has newline\n").unwrap();
    let content = fs::read_to_string(&path).unwrap();
    assert_eq!(content, "has newline\n");
}
```

---

## Stage 2: Error Path Coverage (Est. +35 lines, Target: ~88%)

### 2.1 `MoveDestinationNotDirectory` Error
```rust
#[test]
fn test_run_app_move_dest_is_file_error() {
    let temp = TempDir::new().unwrap();
    let dir = temp.path();
    fs::write(dir.join("file1.txt"), b"dup").unwrap();
    fs::write(dir.join("file2.txt"), b"dup").unwrap();

    // Create a FILE (not dir) as destination
    let dest_file = temp.path().join("dest_as_file");
    fs::write(&dest_file, b"I am a file").unwrap();

    let args = Args {
        directory: dir.to_path_buf(),
        action: Some("move".into()),
        dest: Some(dest_file),
        force: true,
        quiet: true,
        create_dest: false,
        // ... other fields
    };

    let result = run_app(args, Cursor::new(Vec::new()));
    assert!(matches!(result, Err(AppError::MoveDestinationNotDirectory(_))));
}
```

### 2.2 `MoveDestinationMissing` Error (without create_dest)
```rust
#[test]
fn test_run_app_move_dest_missing_no_create() {
    let temp = TempDir::new().unwrap();
    let dir = temp.path();
    fs::write(dir.join("file1.txt"), b"dup").unwrap();
    fs::write(dir.join("file2.txt"), b"dup").unwrap();

    let nonexistent = temp.path().join("does_not_exist");

    let args = Args {
        directory: dir.to_path_buf(),
        action: Some("move".into()),
        dest: Some(nonexistent.clone()),
        force: true,
        quiet: true,
        create_dest: false,  // Key: not creating
        // ...
    };

    let result = run_app(args, Cursor::new(Vec::new()));
    assert!(matches!(result, Err(AppError::MoveDestinationMissing(_))));
}
```

### 2.3 `MoveDestinationCreateFailed` Error
```rust
#[cfg(unix)]
#[test]
fn test_run_app_move_dest_create_fails() {
    let temp = TempDir::new().unwrap();
    let dir = temp.path();
    fs::write(dir.join("file1.txt"), b"dup").unwrap();
    fs::write(dir.join("file2.txt"), b"dup").unwrap();

    // Create read-only parent
    let readonly_parent = temp.path().join("readonly");
    fs::create_dir(&readonly_parent).unwrap();
    let mut perms = fs::metadata(&readonly_parent).unwrap().permissions();
    perms.set_mode(0o555);
    fs::set_permissions(&readonly_parent, perms).unwrap();

    let dest = readonly_parent.join("subdir");

    let args = Args {
        directory: dir.to_path_buf(),
        action: Some("move".into()),
        dest: Some(dest),
        force: true,
        quiet: true,
        create_dest: true,  // Try to create in readonly parent
        // ...
    };

    let result = run_app(args, Cursor::new(Vec::new()));
    assert!(matches!(result, Err(AppError::MoveDestinationCreateFailed(_, _))));

    // Cleanup: restore perms
    perms.set_mode(0o755);
    fs::set_permissions(&readonly_parent, perms).unwrap();
}
```

### 2.4 JSON Summary with Action
```rust
#[test]
fn test_run_app_json_summary_with_delete_action() {
    let temp = TempDir::new().unwrap();
    let dir = temp.path();
    fs::write(dir.join("file1.txt"), b"dup").unwrap();
    fs::write(dir.join("file2.txt"), b"dup").unwrap();

    let args = Args {
        directory: dir.to_path_buf(),
        action: Some("delete".into()),
        dest: None,
        force: true,
        quiet: true,
        create_dest: false,
        follow_symlinks: false,
        summary_format: SummaryFormat::Json,
        summary_path: None,
        summary_silent: false,
        summary_only: false,
        log_level: LogLevel::Info,
        fail_on_error: false,
    };

    let result = run_app(args, Cursor::new(Vec::new()));
    assert!(result.is_ok());
}
```

### 2.5 Warning Logs Path for Failures
```rust
#[test]
fn test_run_app_failure_warning_logs() {
    // Create scenario where action fails and warn_logs is true
    // (log_level = Info or Warn, not quiet, not summary_only)
    // ...
}
```

---

## Stage 3: Main Function Refactoring (Est. +45 lines, Target: ~96%)

The `main()` function currently contains untestable code. We'll refactor it to extract error formatting.

### 3.1 Refactor: Extract Error Display Function
```rust
fn format_app_error(err: &AppError) -> (String, i32) {
    match err {
        AppError::Io(_) => (String::new(), 0), // Let io::Result handle
        AppError::MissingMoveDestination => (
            "Destination directory must be provided for move action.".to_string(),
            1
        ),
        AppError::CreateDestRequiresMove => (
            "--create-dest can only be used together with --action move.".to_string(),
            1
        ),
        AppError::MoveDestinationNotDirectory(path) => (
            format!("Destination path must be a directory: {}", path.display()),
            1
        ),
        AppError::MoveDestinationMissing(path) => (
            format!("Destination directory {} does not exist (use --create-dest to create it).", path.display()),
            1
        ),
        AppError::MoveDestinationCreateFailed(path, err) => (
            format!("Failed to create destination directory {}: {}", path.display(), err),
            1
        ),
        AppError::CtrlCSetup(err) => (
            format!("Failed to install Ctrl+C handler: {}", err),
            1
        ),
        AppError::Cancelled => (
            "Operation cancelled by user.".to_string(),
            130
        ),
        AppError::UnknownAction(action) => (
            format!("Unknown action: {}. Valid options are move, trash or delete.", action),
            1
        ),
        AppError::ActionFailures(count) => (
            format!("Encountered {} action failures; exiting with error as requested.", count),
            2
        ),
    }
}
```

### 3.2 Add Tests for Error Formatting
```rust
#[test]
fn test_format_app_error_missing_move_destination() {
    let (msg, code) = format_app_error(&AppError::MissingMoveDestination);
    assert!(msg.contains("Destination directory must be provided"));
    assert_eq!(code, 1);
}

#[test]
fn test_format_app_error_unknown_action() {
    let (msg, code) = format_app_error(&AppError::UnknownAction("foo".to_string()));
    assert!(msg.contains("foo"));
    assert!(msg.contains("Valid options"));
    assert_eq!(code, 1);
}

#[test]
fn test_format_app_error_cancelled() {
    let (msg, code) = format_app_error(&AppError::Cancelled);
    assert!(msg.contains("cancelled"));
    assert_eq!(code, 130);
}

// ... tests for all error variants
```

---

## Stage 4: Edge Cases and Polish (Est. +8 lines, Target: 98%+)

### 4.1 Cancellation During Process Duplicates
```rust
#[test]
fn test_process_duplicates_cancellation_mid_process() {
    // Set up duplicates, trigger cancellation during iteration
}
```

### 4.2 Invalid Env Var Parsing
```rust
#[test]
fn test_read_duration_from_env_invalid_value() {
    env::set_var("MDDEDUPE_SCAN_PROGRESS_MS", "not_a_number");
    let result = scan_progress_interval();
    assert_eq!(result, Some(Duration::from_millis(DEFAULT_SCAN_PROGRESS_MS)));
    env::remove_var("MDDEDUPE_SCAN_PROGRESS_MS");
}
```

### 4.3 File Without Extension in Unique Destination
```rust
#[test]
fn test_get_unique_destination_no_extension() {
    let temp = TempDir::new().unwrap();
    let dest = temp.path();
    fs::File::create(dest.join("noext")).unwrap();
    fs::File::create(dest.join("noext(1)")).unwrap();

    let unique = get_unique_destination(dest, OsStr::new("noext"));
    assert_eq!(unique.file_name().unwrap(), OsStr::new("noext(2)"));
}
```

---

## Implementation Schedule

| Stage | Description | Est. Tests | Est. Lines Covered |
|-------|-------------|------------|-------------------|
| 1 | Quick Wins | 8-10 | +30 |
| 2 | Error Paths | 6-8 | +35 |
| 3 | Main Refactor | 10 | +45 |
| 4 | Edge Cases | 3-4 | +8 |
| **Total** | | **27-32** | **+118** |

---

## Success Criteria

- [x] Coverage reaches 97.40% (0.6% short of 98% target due to untestable code)
- [x] All 120 tests pass (110 unit + 10 integration)
- [x] No regressions in existing tests
- [x] Build compiles without warnings
- [x] Code follows existing style conventions

---

## Notes

- Platform-specific code (macOS, Windows-specific paths) may not reach 100% on all platforms due to conditional compilation
- The `main()` function will remain partially uncovered after refactoring (the actual `process::exit` calls cannot be tested)
- Cross-device error handling is platform-dependent and may need mocking

---

*Plan created by Claude Code coverage analysis*
