# Implementation Plan – mddedupe Hardening (2025-11-05)

## Goal
Address code-review findings by delivering a safer duplicate-cleanup workflow, resilient progress reporting, and improved maintenance posture while preserving performance characteristics.

## Stage 0 – Preparation (0.5 day)
- Confirm product priorities with stakeholders: clarify desired behavior for `trash`, cross-device moves, quiet mode expectations, and symlink handling.
- Define success metrics (e.g., zero destructive surprises, passes new test matrix, memory usage stable under 10M-file scan scenarios in staging).
- Create tracking issues per stage in the project board.

## Stage 1 – Safety-Critical Actions (1.5 days)
- **Real Trash Integration:** Replace simulated trash branch with platform-aware implementation (prefer `trash` crate). Provide feature flag for fallback environments.
- **Action Validation:** Fail fast during CLI parsing if `--action=move` lacks existing directory. Optionally add `--create-dest` flag to mkdir when needed.
- **Error Aggregation:** Refactor `process_duplicates` to catch per-file errors, push them into a report structure, and print summary at the end while continuing other files.
- **Cross-Device Move Support:** When `fs::rename` returns `EXDEV`, fall back to copy + fsync + remove. Ensure unique destination generation re-runs post-copy.
- Deliverables: updated action pipeline, structured error reporting, expanded unit tests & integration test covering `move/delete/trash` unhappy paths.

## Stage 2 – Resilience & UX (1 day)
- **Progress Reporting:** Guard flush/print calls; downgrade to debug logging on EPIPE. Suppress progress thread in quiet mode or change to stderr logging.
- **Graceful Shutdown:** Add cancellation hook (Ctrl+C) to ensure progress thread exits cleanly and partial results are summarized.
- **Symlink Policy:** Decide default (skip vs follow). Implement flag `--follow-symlinks` if required; document behavior in README.
- **Summary Clarity:** On completion, display counts of succeeded vs failed file actions from Stage 1 error aggregation.
- Deliverables: updated UX behavior, tests for quiet mode and broken pipe scenario (using `assert_cmd` pipelines).

## Stage 3 – Scalability & Memory (1 day)
- **Duplicate Map Optimization:** Discard singleton hash groups immediately to reduce memory, or restructure to stream results.
- **Chunked Progress Tracking:** Batch atomic increments to reduce contention when hashing many small files.
- **Benchmark Harness:** Add `cargo bench` or criterion benchmarks simulating large trees; record baseline memory and runtime.
- Deliverables: profiling notes, optional feature flags for low-memory mode.

## Stage 4 – Maintenance & Dependencies (0.5 day)
- Replace `ansi_term` with maintained alternative (`nu-ansi-term` or `yansi`) and update color usage.
- Audit dependency versions; run `cargo audit` and incorporate into CI.
- Update README with new flags, behavior guarantees, and known limitations.

## Stage 5 – Test Strategy Expansion (1 day)
- Build table-driven tests for CLI parsing (invalid combinations, force confirmations, dest validation).
- Add filesystem error simulations using tempdirs with chmod restrictions to ensure error aggregation works.
- Introduce integration tests that exercise entire run via `assert_cmd` capturing stdout/stderr; include quiet mode, pipe-to-head scenario, and cross-device move simulation (mock or double-mount in CI if feasible).

## Stage 6 – Release & Follow-Up (0.5 day)
- Update version to `0.2.0`, document changes in CHANGELOG.
- Run full CI matrix, including new benchmarks and audits.
- Tag release and communicate results; gather user feedback for backlog triage.

## Dependencies & Ordering Notes
- Stage 1 blocks all subsequent stages; Stage 2 can run in parallel with Stage 3 once Stage 1 branch lands.
- Progress reporting adjustments (Stage 2) should integrate with error aggregation from Stage 1.
- Benchmarking from Stage 3 depends on memory optimizations to capture new baseline.
- Dependency updates (Stage 4) should happen after behavioral changes to avoid interleaved regressions.
- Expanded tests (Stage 5) are cumulative; aim to land alongside Stage 1/2 changes to prevent regressions.

## Risk Mitigation
- Use feature flags or environment toggles for trash integration to allow fallback when OS support is incomplete.
- Implement dry-run mode for integration tests to avoid accidental deletes on developer machines.
- Document manual rollback procedure (restore from move destination, re-run with `--action delete` disabled) in README.

## Metrics & Verification
- All new tests green on CI; additional integration suite capturing action failures.
- Manual smoke test on 100k-file sandbox verifying progress behavior and error summary.
- Memory profiling shows reduced RSS compared to pre-change baseline in Stage 3 benchmark.
