# Comprehensive Code Review – 2025-11-21

## Scope
- Code: `src/main.rs` (CLI, scanning, hashing, actions, summaries, progress/cancel), tests inside module; integration tests in `tests/cli.rs`.
- Config/docs consulted: `Cargo.toml`, `readme.md`, `docs/usage.md`, `ARCHITECTURE.md` (overview only).

## Overall
- All tests pass: `cargo test` (2025-11-21). No immediate regressions observed.
- Core flow is clear and matches documented behavior: size bucketing + parallel SHA-256, stable primary file selection, safe defaults, confirmation gates, JSON/text summaries, broken-pipe handling.

## Strengths
- Good guardrails: read-only default, confirmation prompt unless `--force`, unique destination naming to avoid overwrites, cross-device move fallback with fsync (`relocate_file` line 547).
- Resilience touches: broken-pipe tolerance in progress writer, cancellation flag plumbed through scan/hash/action, summary writing ensures parent dirs and trailing newline.
- Tests cover main happy paths and many edge cases (permission errors, broken pipes, prompt cancellation, summary flags, move/trash/delete variants, symlink respect toggle on Unix).

## Findings
- [High] Possible infinite traversal when `--follow-symlinks` is enabled. `WalkDir::new(dir).follow_links(follow_symlinks)` (src/main.rs:185-187) follows symlinks without cycle detection. A symlink loop (e.g., self-referential dir link) will cause unbounded traversal and hashing, potentially hanging or blowing memory/CPU. WalkDir docs recommend tracking visited inodes or setting `max_depth`/`same_file_system` when following links. Suggest adding cycle detection (e.g., `walkdir::WalkDir::new(...).follow_links(true).same_file_system(true)` plus inode set) or explicitly documenting and guarding against loops.
- [Medium] Progress interval env vars ignore zero/short values. `read_duration_from_env` filters out non-positive parsed values (line 122-128), so `MDDEDUPE_*_PROGRESS_MS=0` falls back to 1s/500ms defaults. Tests and docs set these vars to reduce noise/latency, but the current code cannot disable or speed up progress via env. Consider treating 0 as “no delay” (or “disable progress updates”) and accepting small values to honor user intent, especially in CI/piped usage.
- [Medium] Errors are effectively hidden when `--log-level none`. `error_logs` is false in that mode (lines 761-768), so action failures only land in `summary_lines` (lines 929-947) which are never emitted unless `--summary-path` is used. A run with `--log-level none` and no summary file can therefore silently skip undeletable files while still printing “Operation complete” (lines 914-926). Recommend always surfacing failure counts (and optionally paths) in the final summary regardless of log level, or forbidding `none` from suppressing error output.
- [Low] Symlink-follow flag not covered by tests for cycle behavior or Windows paths; cross-device move/trash paths also untested. Consider targeted tests to lock down new safeguards and JSON action summaries (currently not validated when actions run).

## Test Results
- `cargo test` (2025-11-21) – all 36 tests pass.

## Recommendations
1) Mitigate symlink-loop risk before shipping `--follow-symlinks`: add inode/stack detection or constrain traversal, and add a regression test with a self-referential symlink.
2) Honor progress env variables as users set them (allow 0/non-positive to mean “disable” or “no delay”); update docs/tests accordingly.
3) Always report action failures even at `--log-level none` (e.g., print a one-line failure summary to stderr/stdout) to avoid silent data-loss or partial actions.
4) Add regression tests for the above changes plus JSON summaries with actions and cross-device move/trash fallbacks.
